// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type EncryptionDetailsInitParameters struct {

	// a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
	SseEncryptionDetails []SseEncryptionDetailsInitParameters `json:"sseEncryptionDetails,omitempty" tf:"sse_encryption_details,omitempty"`
}

type EncryptionDetailsObservation struct {

	// a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
	SseEncryptionDetails []SseEncryptionDetailsObservation `json:"sseEncryptionDetails,omitempty" tf:"sse_encryption_details,omitempty"`
}

type EncryptionDetailsParameters struct {

	// a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
	// +kubebuilder:validation:Optional
	SseEncryptionDetails []SseEncryptionDetailsParameters `json:"sseEncryptionDetails,omitempty" tf:"sse_encryption_details,omitempty"`
}

type ExternalLocationInitParameters struct {

	// User-supplied free-form text.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Name of the databricks_storage_credential to use with this external location.
	CredentialName *string `json:"credentialName,omitempty" tf:"credential_name,omitempty"`

	// indicates if managed file events are enabled for this external location.  Requires file_event_queue block.
	EnableFileEvents *bool `json:"enableFileEvents,omitempty" tf:"enable_file_events,omitempty"`

	EncryptionDetails []EncryptionDetailsInitParameters `json:"encryptionDetails,omitempty" tf:"encryption_details,omitempty"`

	// Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled (disabled by default), the access to the location falls back to cluster credentials if UC credentials are not sufficient.
	Fallback *bool `json:"fallback,omitempty" tf:"fallback,omitempty"`

	FileEventQueue []FileEventQueueInitParameters `json:"fileEventQueue,omitempty" tf:"file_event_queue,omitempty"`

	// Destroy external location regardless of its dependents.
	ForceDestroy *bool `json:"forceDestroy,omitempty" tf:"force_destroy,omitempty"`

	// Update external location regardless of its dependents.
	ForceUpdate *bool `json:"forceUpdate,omitempty" tf:"force_update,omitempty"`

	// Whether the external location is accessible from all workspaces or a specific set of workspaces. Can be ISOLATION_MODE_ISOLATED or ISOLATION_MODE_OPEN. Setting the external location to ISOLATION_MODE_ISOLATED will automatically allow access from the current workspace.
	IsolationMode *string `json:"isolationMode,omitempty" tf:"isolation_mode,omitempty"`

	// ID of this external location - same as name.
	MetastoreID *string `json:"metastoreId,omitempty" tf:"metastore_id,omitempty"`

	// Name of External Location, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Username/groupname/sp application_id of the external location owner.
	Owner *string `json:"owner,omitempty" tf:"owner,omitempty"`

	// Indicates whether the external location is read-only.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Suppress validation errors if any & force save the external location
	SkipValidation *bool `json:"skipValidation,omitempty" tf:"skip_validation,omitempty"`

	// Path URL in cloud storage, of the form: s3://[bucket-host]/[bucket-dir] (AWS), abfss://[user]@[host]/[path] (Azure), gs://[bucket-host]/[bucket-dir] (GCP).
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ExternalLocationObservation struct {
	BrowseOnly *bool `json:"browseOnly,omitempty" tf:"browse_only,omitempty"`

	// User-supplied free-form text.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Time at which this external location was created, in epoch milliseconds.
	CreatedAt *float64 `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Username of external location creator.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// Unique ID of the location's storage credential.
	CredentialID *string `json:"credentialId,omitempty" tf:"credential_id,omitempty"`

	// Name of the databricks_storage_credential to use with this external location.
	CredentialName *string `json:"credentialName,omitempty" tf:"credential_name,omitempty"`

	// indicates if managed file events are enabled for this external location.  Requires file_event_queue block.
	EnableFileEvents *bool `json:"enableFileEvents,omitempty" tf:"enable_file_events,omitempty"`

	EncryptionDetails []EncryptionDetailsObservation `json:"encryptionDetails,omitempty" tf:"encryption_details,omitempty"`

	// Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled (disabled by default), the access to the location falls back to cluster credentials if UC credentials are not sufficient.
	Fallback *bool `json:"fallback,omitempty" tf:"fallback,omitempty"`

	FileEventQueue []FileEventQueueObservation `json:"fileEventQueue,omitempty" tf:"file_event_queue,omitempty"`

	// Destroy external location regardless of its dependents.
	ForceDestroy *bool `json:"forceDestroy,omitempty" tf:"force_destroy,omitempty"`

	// Update external location regardless of its dependents.
	ForceUpdate *bool `json:"forceUpdate,omitempty" tf:"force_update,omitempty"`

	// ID of this external location - same as name.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Whether the external location is accessible from all workspaces or a specific set of workspaces. Can be ISOLATION_MODE_ISOLATED or ISOLATION_MODE_OPEN. Setting the external location to ISOLATION_MODE_ISOLATED will automatically allow access from the current workspace.
	IsolationMode *string `json:"isolationMode,omitempty" tf:"isolation_mode,omitempty"`

	// ID of this external location - same as name.
	MetastoreID *string `json:"metastoreId,omitempty" tf:"metastore_id,omitempty"`

	// Name of External Location, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Username/groupname/sp application_id of the external location owner.
	Owner *string `json:"owner,omitempty" tf:"owner,omitempty"`

	// Indicates whether the external location is read-only.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Suppress validation errors if any & force save the external location
	SkipValidation *bool `json:"skipValidation,omitempty" tf:"skip_validation,omitempty"`

	// Path URL in cloud storage, of the form: s3://[bucket-host]/[bucket-dir] (AWS), abfss://[user]@[host]/[path] (Azure), gs://[bucket-host]/[bucket-dir] (GCP).
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// Time at which external location this was last modified, in epoch milliseconds.
	UpdatedAt *float64 `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`

	// Username of user who last modified the external location.
	UpdatedBy *string `json:"updatedBy,omitempty" tf:"updated_by,omitempty"`
}

type ExternalLocationParameters struct {

	// User-supplied free-form text.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Name of the databricks_storage_credential to use with this external location.
	// +kubebuilder:validation:Optional
	CredentialName *string `json:"credentialName,omitempty" tf:"credential_name,omitempty"`

	// indicates if managed file events are enabled for this external location.  Requires file_event_queue block.
	// +kubebuilder:validation:Optional
	EnableFileEvents *bool `json:"enableFileEvents,omitempty" tf:"enable_file_events,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionDetails []EncryptionDetailsParameters `json:"encryptionDetails,omitempty" tf:"encryption_details,omitempty"`

	// Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled (disabled by default), the access to the location falls back to cluster credentials if UC credentials are not sufficient.
	// +kubebuilder:validation:Optional
	Fallback *bool `json:"fallback,omitempty" tf:"fallback,omitempty"`

	// +kubebuilder:validation:Optional
	FileEventQueue []FileEventQueueParameters `json:"fileEventQueue,omitempty" tf:"file_event_queue,omitempty"`

	// Destroy external location regardless of its dependents.
	// +kubebuilder:validation:Optional
	ForceDestroy *bool `json:"forceDestroy,omitempty" tf:"force_destroy,omitempty"`

	// Update external location regardless of its dependents.
	// +kubebuilder:validation:Optional
	ForceUpdate *bool `json:"forceUpdate,omitempty" tf:"force_update,omitempty"`

	// Whether the external location is accessible from all workspaces or a specific set of workspaces. Can be ISOLATION_MODE_ISOLATED or ISOLATION_MODE_OPEN. Setting the external location to ISOLATION_MODE_ISOLATED will automatically allow access from the current workspace.
	// +kubebuilder:validation:Optional
	IsolationMode *string `json:"isolationMode,omitempty" tf:"isolation_mode,omitempty"`

	// ID of this external location - same as name.
	// +kubebuilder:validation:Optional
	MetastoreID *string `json:"metastoreId,omitempty" tf:"metastore_id,omitempty"`

	// Name of External Location, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Username/groupname/sp application_id of the external location owner.
	// +kubebuilder:validation:Optional
	Owner *string `json:"owner,omitempty" tf:"owner,omitempty"`

	// Indicates whether the external location is read-only.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Suppress validation errors if any & force save the external location
	// +kubebuilder:validation:Optional
	SkipValidation *bool `json:"skipValidation,omitempty" tf:"skip_validation,omitempty"`

	// Path URL in cloud storage, of the form: s3://[bucket-host]/[bucket-dir] (AWS), abfss://[user]@[host]/[path] (Azure), gs://[bucket-host]/[bucket-dir] (GCP).
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type FileEventQueueInitParameters struct {

	// Configuration for managed Azure Queue Storage queue.
	ManagedAqs []ManagedAqsInitParameters `json:"managedAqs,omitempty" tf:"managed_aqs,omitempty"`

	// Configuration for managed Google Cloud Pub/Sub queue.
	ManagedPubsub []ManagedPubsubInitParameters `json:"managedPubsub,omitempty" tf:"managed_pubsub,omitempty"`

	// Configuration for managed Amazon SQS queue.
	ManagedSqs []ManagedSqsInitParameters `json:"managedSqs,omitempty" tf:"managed_sqs,omitempty"`

	// Configuration for provided Azure Storage Queue.
	ProvidedAqs []ProvidedAqsInitParameters `json:"providedAqs,omitempty" tf:"provided_aqs,omitempty"`

	// Configuration for provided Google Cloud Pub/Sub queue.
	ProvidedPubsub []ProvidedPubsubInitParameters `json:"providedPubsub,omitempty" tf:"provided_pubsub,omitempty"`

	// Configuration for provided Amazon SQS queue.
	ProvidedSqs []ProvidedSqsInitParameters `json:"providedSqs,omitempty" tf:"provided_sqs,omitempty"`
}

type FileEventQueueObservation struct {

	// Configuration for managed Azure Queue Storage queue.
	ManagedAqs []ManagedAqsObservation `json:"managedAqs,omitempty" tf:"managed_aqs,omitempty"`

	// Configuration for managed Google Cloud Pub/Sub queue.
	ManagedPubsub []ManagedPubsubObservation `json:"managedPubsub,omitempty" tf:"managed_pubsub,omitempty"`

	// Configuration for managed Amazon SQS queue.
	ManagedSqs []ManagedSqsObservation `json:"managedSqs,omitempty" tf:"managed_sqs,omitempty"`

	// Configuration for provided Azure Storage Queue.
	ProvidedAqs []ProvidedAqsObservation `json:"providedAqs,omitempty" tf:"provided_aqs,omitempty"`

	// Configuration for provided Google Cloud Pub/Sub queue.
	ProvidedPubsub []ProvidedPubsubObservation `json:"providedPubsub,omitempty" tf:"provided_pubsub,omitempty"`

	// Configuration for provided Amazon SQS queue.
	ProvidedSqs []ProvidedSqsObservation `json:"providedSqs,omitempty" tf:"provided_sqs,omitempty"`
}

type FileEventQueueParameters struct {

	// Configuration for managed Azure Queue Storage queue.
	// +kubebuilder:validation:Optional
	ManagedAqs []ManagedAqsParameters `json:"managedAqs,omitempty" tf:"managed_aqs,omitempty"`

	// Configuration for managed Google Cloud Pub/Sub queue.
	// +kubebuilder:validation:Optional
	ManagedPubsub []ManagedPubsubParameters `json:"managedPubsub,omitempty" tf:"managed_pubsub,omitempty"`

	// Configuration for managed Amazon SQS queue.
	// +kubebuilder:validation:Optional
	ManagedSqs []ManagedSqsParameters `json:"managedSqs,omitempty" tf:"managed_sqs,omitempty"`

	// Configuration for provided Azure Storage Queue.
	// +kubebuilder:validation:Optional
	ProvidedAqs []ProvidedAqsParameters `json:"providedAqs,omitempty" tf:"provided_aqs,omitempty"`

	// Configuration for provided Google Cloud Pub/Sub queue.
	// +kubebuilder:validation:Optional
	ProvidedPubsub []ProvidedPubsubParameters `json:"providedPubsub,omitempty" tf:"provided_pubsub,omitempty"`

	// Configuration for provided Amazon SQS queue.
	// +kubebuilder:validation:Optional
	ProvidedSqs []ProvidedSqsParameters `json:"providedSqs,omitempty" tf:"provided_sqs,omitempty"`
}

type ManagedAqsInitParameters struct {

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`

	// The Azure resource group.
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`
}

type ManagedAqsObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`

	// The Azure resource group.
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`
}

type ManagedAqsParameters struct {

	// The URL of the queue.
	// +kubebuilder:validation:Optional
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`

	// The Azure resource group.
	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	// +kubebuilder:validation:Optional
	SubscriptionID *string `json:"subscriptionId" tf:"subscription_id,omitempty"`
}

type ManagedPubsubInitParameters struct {

	// The name of the subscription.
	SubscriptionName *string `json:"subscriptionName,omitempty" tf:"subscription_name,omitempty"`
}

type ManagedPubsubObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The name of the subscription.
	SubscriptionName *string `json:"subscriptionName,omitempty" tf:"subscription_name,omitempty"`
}

type ManagedPubsubParameters struct {

	// The name of the subscription.
	// +kubebuilder:validation:Optional
	SubscriptionName *string `json:"subscriptionName,omitempty" tf:"subscription_name,omitempty"`
}

type ManagedSqsInitParameters struct {

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`
}

type ManagedSqsObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`
}

type ManagedSqsParameters struct {

	// The URL of the queue.
	// +kubebuilder:validation:Optional
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`
}

type ProvidedAqsInitParameters struct {

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`

	// The Azure resource group.
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`
}

type ProvidedAqsObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`

	// The Azure resource group.
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`
}

type ProvidedAqsParameters struct {

	// The URL of the queue.
	// +kubebuilder:validation:Optional
	QueueURL *string `json:"queueUrl" tf:"queue_url,omitempty"`

	// The Azure resource group.
	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The Azure subscription ID.
	// +kubebuilder:validation:Optional
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`
}

type ProvidedPubsubInitParameters struct {

	// The name of the subscription.
	SubscriptionName *string `json:"subscriptionName,omitempty" tf:"subscription_name,omitempty"`
}

type ProvidedPubsubObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The name of the subscription.
	SubscriptionName *string `json:"subscriptionName,omitempty" tf:"subscription_name,omitempty"`
}

type ProvidedPubsubParameters struct {

	// The name of the subscription.
	// +kubebuilder:validation:Optional
	SubscriptionName *string `json:"subscriptionName" tf:"subscription_name,omitempty"`
}

type ProvidedSqsInitParameters struct {

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`
}

type ProvidedSqsObservation struct {

	// (Computed) The ID of the managed resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty" tf:"managed_resource_id,omitempty"`

	// The URL of the queue.
	QueueURL *string `json:"queueUrl,omitempty" tf:"queue_url,omitempty"`
}

type ProvidedSqsParameters struct {

	// The URL of the queue.
	// +kubebuilder:validation:Optional
	QueueURL *string `json:"queueUrl" tf:"queue_url,omitempty"`
}

type SseEncryptionDetailsInitParameters struct {

	// Encryption algorithm value. Sets the value of the x-amz-server-side-encryption header in S3 request.
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Optional ARN of the SSE-KMS key used with the S3 location, when algorithm = "SSE-KMS". Sets the value of the x-amz-server-side-encryption-aws-kms-key-id header.
	AwsKMSKeyArn *string `json:"awsKmsKeyArn,omitempty" tf:"aws_kms_key_arn,omitempty"`
}

type SseEncryptionDetailsObservation struct {

	// Encryption algorithm value. Sets the value of the x-amz-server-side-encryption header in S3 request.
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Optional ARN of the SSE-KMS key used with the S3 location, when algorithm = "SSE-KMS". Sets the value of the x-amz-server-side-encryption-aws-kms-key-id header.
	AwsKMSKeyArn *string `json:"awsKmsKeyArn,omitempty" tf:"aws_kms_key_arn,omitempty"`
}

type SseEncryptionDetailsParameters struct {

	// Encryption algorithm value. Sets the value of the x-amz-server-side-encryption header in S3 request.
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Optional ARN of the SSE-KMS key used with the S3 location, when algorithm = "SSE-KMS". Sets the value of the x-amz-server-side-encryption-aws-kms-key-id header.
	// +kubebuilder:validation:Optional
	AwsKMSKeyArn *string `json:"awsKmsKeyArn,omitempty" tf:"aws_kms_key_arn,omitempty"`
}

// ExternalLocationSpec defines the desired state of ExternalLocation
type ExternalLocationSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            ExternalLocationParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ExternalLocationInitParameters `json:"initProvider,omitempty"`
}

// ExternalLocationStatus defines the observed state of ExternalLocation.
type ExternalLocationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ExternalLocationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ExternalLocation is the Schema for the ExternalLocations API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,databricks}
type ExternalLocation struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.credentialName) || (has(self.initProvider) && has(self.initProvider.credentialName))",message="spec.forProvider.credentialName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.url) || (has(self.initProvider) && has(self.initProvider.url))",message="spec.forProvider.url is a required parameter"
	Spec   ExternalLocationSpec   `json:"spec"`
	Status ExternalLocationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ExternalLocationList contains a list of ExternalLocations
type ExternalLocationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ExternalLocation `json:"items"`
}

// Repository type metadata.
var (
	ExternalLocation_Kind             = "ExternalLocation"
	ExternalLocation_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ExternalLocation_Kind}.String()
	ExternalLocation_KindAPIVersion   = ExternalLocation_Kind + "." + CRDGroupVersion.String()
	ExternalLocation_GroupVersionKind = CRDGroupVersion.WithKind(ExternalLocation_Kind)
)

func init() {
	SchemeBuilder.Register(&ExternalLocation{}, &ExternalLocationList{})
}
