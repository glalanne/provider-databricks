// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type AbfsInitParameters struct {

	// (String) This is the client_id (Application Object ID) for the enterprise application for the service principal.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// Reference to a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeyRef *v1.NamespacedReference `json:"clientSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeySelector *v1.NamespacedSelector `json:"clientSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeRef *v1.NamespacedReference `json:"clientSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeSelector *v1.NamespacedSelector `json:"clientSecretScopeSelector,omitempty" tf:"-"`

	// (String) ADLS gen2 container name. (Could be omitted if resource_id is provided)
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (Bool) either or not initialize FS for the first use
	InitializeFileSystem *bool `json:"initializeFileSystem,omitempty" tf:"initialize_file_system,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it).
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AbfsObservation struct {

	// (String) This is the client_id (Application Object ID) for the enterprise application for the service principal.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// (String) ADLS gen2 container name. (Could be omitted if resource_id is provided)
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (Bool) either or not initialize FS for the first use
	InitializeFileSystem *bool `json:"initializeFileSystem,omitempty" tf:"initialize_file_system,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it).
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AbfsParameters struct {

	// (String) This is the client_id (Application Object ID) for the enterprise application for the service principal.
	// +kubebuilder:validation:Optional
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	// +kubebuilder:validation:Optional
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// Reference to a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeyRef *v1.NamespacedReference `json:"clientSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeySelector *v1.NamespacedSelector `json:"clientSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeRef *v1.NamespacedReference `json:"clientSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeSelector *v1.NamespacedSelector `json:"clientSecretScopeSelector,omitempty" tf:"-"`

	// (String) ADLS gen2 container name. (Could be omitted if resource_id is provided)
	// +kubebuilder:validation:Optional
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	// +kubebuilder:validation:Optional
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (Bool) either or not initialize FS for the first use
	// +kubebuilder:validation:Optional
	InitializeFileSystem *bool `json:"initializeFileSystem" tf:"initialize_file_system,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	// +kubebuilder:validation:Optional
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it).
	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AdlInitParameters struct {

	// (String) This is the client_id for the enterprise application for the service principal.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// Reference to a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeyRef *v1.NamespacedReference `json:"clientSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeySelector *v1.NamespacedSelector `json:"clientSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeRef *v1.NamespacedReference `json:"clientSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeSelector *v1.NamespacedSelector `json:"clientSecretScopeSelector,omitempty" tf:"-"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) This is the spark configuration prefix for adls gen 1 mount. The options are fs.adl, dfs.adls. Use fs.adl for runtime 6.0 and above for the clusters. Otherwise use dfs.adls. The default value is: fs.adl.
	SparkConfPrefix *string `json:"sparkConfPrefix,omitempty" tf:"spark_conf_prefix,omitempty"`

	// (String) The name of the storage resource in which the data is for ADLS gen 1. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	StorageResourceName *string `json:"storageResourceName,omitempty" tf:"storage_resource_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it)
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AdlObservation struct {

	// (String) This is the client_id for the enterprise application for the service principal.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) This is the spark configuration prefix for adls gen 1 mount. The options are fs.adl, dfs.adls. Use fs.adl for runtime 6.0 and above for the clusters. Otherwise use dfs.adls. The default value is: fs.adl.
	SparkConfPrefix *string `json:"sparkConfPrefix,omitempty" tf:"spark_conf_prefix,omitempty"`

	// (String) The name of the storage resource in which the data is for ADLS gen 1. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	StorageResourceName *string `json:"storageResourceName,omitempty" tf:"storage_resource_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it)
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AdlParameters struct {

	// (String) This is the client_id for the enterprise application for the service principal.
	// +kubebuilder:validation:Optional
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// (String) This is the secret key in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	// +kubebuilder:validation:Optional
	ClientSecretKey *string `json:"clientSecretKey,omitempty" tf:"client_secret_key,omitempty"`

	// Reference to a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeyRef *v1.NamespacedReference `json:"clientSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate clientSecretKey.
	// +kubebuilder:validation:Optional
	ClientSecretKeySelector *v1.NamespacedSelector `json:"clientSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your service principal/enterprise app client secret will be stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	ClientSecretScope *string `json:"clientSecretScope,omitempty" tf:"client_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeRef *v1.NamespacedReference `json:"clientSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate clientSecretScope.
	// +kubebuilder:validation:Optional
	ClientSecretScopeSelector *v1.NamespacedSelector `json:"clientSecretScopeSelector,omitempty" tf:"-"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	// +kubebuilder:validation:Optional
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) This is the spark configuration prefix for adls gen 1 mount. The options are fs.adl, dfs.adls. Use fs.adl for runtime 6.0 and above for the clusters. Otherwise use dfs.adls. The default value is: fs.adl.
	// +kubebuilder:validation:Optional
	SparkConfPrefix *string `json:"sparkConfPrefix,omitempty" tf:"spark_conf_prefix,omitempty"`

	// (String) The name of the storage resource in which the data is for ADLS gen 1. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	// +kubebuilder:validation:Optional
	StorageResourceName *string `json:"storageResourceName,omitempty" tf:"storage_resource_name,omitempty"`

	// (String) This is your azure directory tenant id. It is required for creating the mount. (Could be omitted if Azure authentication is used, and we can extract tenant_id from it)
	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type GsInitParameters struct {

	// (String) GCS bucket name to be mounted.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// (String) email of registered Google Service Account for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have a Google service account attached to it.
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type GsObservation struct {

	// (String) GCS bucket name to be mounted.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// (String) email of registered Google Service Account for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have a Google service account attached to it.
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type GsParameters struct {

	// (String) GCS bucket name to be mounted.
	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// (String) email of registered Google Service Account for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have a Google service account attached to it.
	// +kubebuilder:validation:Optional
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
}

type MountInitParameters struct {

	// to mount ADLS Gen2 using Azure Blob Filesystem (ABFS) driver
	Abfs *AbfsInitParameters `json:"abfs,omitempty" tf:"abfs,omitempty"`

	// to mount ADLS Gen1 using Azure Data Lake (ADL) driver
	Adl *AdlInitParameters `json:"adl,omitempty" tf:"adl,omitempty"`

	// Cluster to use for mounting. If no cluster is specified, a new cluster will be created and will mount the bucket for all of the clusters in this workspace. If the cluster is not running - it's going to be started, so be aware to set auto-termination rules on it.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/compute/v1alpha1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster in compute to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.NamespacedReference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster in compute to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.NamespacedSelector `json:"clusterIdSelector,omitempty" tf:"-"`

	// encryption type. Currently used only for AWS S3 mounts
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// configuration parameters that are necessary for mounting of specific storage
	// +mapType=granular
	ExtraConfigs map[string]*string `json:"extraConfigs,omitempty" tf:"extra_configs,omitempty"`

	// to mount Google Cloud Storage
	Gs *GsInitParameters `json:"gs,omitempty" tf:"gs,omitempty"`

	// Name, under which mount will be accessible in dbfs:/mnt/<MOUNT_NAME>. If not specified, provider will try to infer it from depending on the resource type:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// resource ID for a given storage account. Could be used to fill defaults, such as storage account & container names on Azure.
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// to mount AWS S3
	S3 *S3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`

	// the URI for accessing specific storage (s3a://...., abfss://...., gs://...., etc.)
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// to mount Azure Blob Storage using Windows Azure Storage Blob (WASB) driver
	Wasb *WasbInitParameters `json:"wasb,omitempty" tf:"wasb,omitempty"`
}

type MountObservation struct {

	// to mount ADLS Gen2 using Azure Blob Filesystem (ABFS) driver
	Abfs *AbfsObservation `json:"abfs,omitempty" tf:"abfs,omitempty"`

	// to mount ADLS Gen1 using Azure Data Lake (ADL) driver
	Adl *AdlObservation `json:"adl,omitempty" tf:"adl,omitempty"`

	// Cluster to use for mounting. If no cluster is specified, a new cluster will be created and will mount the bucket for all of the clusters in this workspace. If the cluster is not running - it's going to be started, so be aware to set auto-termination rules on it.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// encryption type. Currently used only for AWS S3 mounts
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// configuration parameters that are necessary for mounting of specific storage
	// +mapType=granular
	ExtraConfigs map[string]*string `json:"extraConfigs,omitempty" tf:"extra_configs,omitempty"`

	// to mount Google Cloud Storage
	Gs *GsObservation `json:"gs,omitempty" tf:"gs,omitempty"`

	// mount name
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name, under which mount will be accessible in dbfs:/mnt/<MOUNT_NAME>. If not specified, provider will try to infer it from depending on the resource type:
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// resource ID for a given storage account. Could be used to fill defaults, such as storage account & container names on Azure.
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// to mount AWS S3
	S3 *S3Observation `json:"s3,omitempty" tf:"s3,omitempty"`

	// (String) HDFS-compatible url
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// the URI for accessing specific storage (s3a://...., abfss://...., gs://...., etc.)
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// to mount Azure Blob Storage using Windows Azure Storage Blob (WASB) driver
	Wasb *WasbObservation `json:"wasb,omitempty" tf:"wasb,omitempty"`
}

type MountParameters struct {

	// to mount ADLS Gen2 using Azure Blob Filesystem (ABFS) driver
	// +kubebuilder:validation:Optional
	Abfs *AbfsParameters `json:"abfs,omitempty" tf:"abfs,omitempty"`

	// to mount ADLS Gen1 using Azure Data Lake (ADL) driver
	// +kubebuilder:validation:Optional
	Adl *AdlParameters `json:"adl,omitempty" tf:"adl,omitempty"`

	// Cluster to use for mounting. If no cluster is specified, a new cluster will be created and will mount the bucket for all of the clusters in this workspace. If the cluster is not running - it's going to be started, so be aware to set auto-termination rules on it.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/compute/v1alpha1.Cluster
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster in compute to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.NamespacedReference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster in compute to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.NamespacedSelector `json:"clusterIdSelector,omitempty" tf:"-"`

	// encryption type. Currently used only for AWS S3 mounts
	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// configuration parameters that are necessary for mounting of specific storage
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ExtraConfigs map[string]*string `json:"extraConfigs,omitempty" tf:"extra_configs,omitempty"`

	// to mount Google Cloud Storage
	// +kubebuilder:validation:Optional
	Gs *GsParameters `json:"gs,omitempty" tf:"gs,omitempty"`

	// Name, under which mount will be accessible in dbfs:/mnt/<MOUNT_NAME>. If not specified, provider will try to infer it from depending on the resource type:
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// resource ID for a given storage account. Could be used to fill defaults, such as storage account & container names on Azure.
	// +kubebuilder:validation:Optional
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// to mount AWS S3
	// +kubebuilder:validation:Optional
	S3 *S3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`

	// the URI for accessing specific storage (s3a://...., abfss://...., gs://...., etc.)
	// +kubebuilder:validation:Optional
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// to mount Azure Blob Storage using Windows Azure Storage Blob (WASB) driver
	// +kubebuilder:validation:Optional
	Wasb *WasbParameters `json:"wasb,omitempty" tf:"wasb,omitempty"`
}

type S3InitParameters struct {

	// (String) S3 bucket name to be mounted.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// (String) ARN of registered instance profile for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have an instance profile attached to it. If both cluster_id & instance_profile are specified, then cluster_id takes precedence.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/deployment/v1alpha1.InstanceProfile
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	InstanceProfile *string `json:"instanceProfile,omitempty" tf:"instance_profile,omitempty"`

	// Reference to a InstanceProfile in deployment to populate instanceProfile.
	// +kubebuilder:validation:Optional
	InstanceProfileRef *v1.NamespacedReference `json:"instanceProfileRef,omitempty" tf:"-"`

	// Selector for a InstanceProfile in deployment to populate instanceProfile.
	// +kubebuilder:validation:Optional
	InstanceProfileSelector *v1.NamespacedSelector `json:"instanceProfileSelector,omitempty" tf:"-"`
}

type S3Observation struct {

	// (String) S3 bucket name to be mounted.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// (String) ARN of registered instance profile for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have an instance profile attached to it. If both cluster_id & instance_profile are specified, then cluster_id takes precedence.
	InstanceProfile *string `json:"instanceProfile,omitempty" tf:"instance_profile,omitempty"`
}

type S3Parameters struct {

	// (String) S3 bucket name to be mounted.
	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// (String) ARN of registered instance profile for data access.  If it's not specified, then the cluster_id should be provided, and the cluster should have an instance profile attached to it. If both cluster_id & instance_profile are specified, then cluster_id takes precedence.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/deployment/v1alpha1.InstanceProfile
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	InstanceProfile *string `json:"instanceProfile,omitempty" tf:"instance_profile,omitempty"`

	// Reference to a InstanceProfile in deployment to populate instanceProfile.
	// +kubebuilder:validation:Optional
	InstanceProfileRef *v1.NamespacedReference `json:"instanceProfileRef,omitempty" tf:"-"`

	// Selector for a InstanceProfile in deployment to populate instanceProfile.
	// +kubebuilder:validation:Optional
	InstanceProfileSelector *v1.NamespacedSelector `json:"instanceProfileSelector,omitempty" tf:"-"`
}

type WasbInitParameters struct {

	// (String) This is the auth type for blob storage. This can either be SAS tokens (SAS) or account access keys (ACCESS_KEY).
	AuthType *string `json:"authType,omitempty" tf:"auth_type,omitempty"`

	// (String) The container in which the data is. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is the secret key in which your auth type token is stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	TokenSecretKey *string `json:"tokenSecretKey,omitempty" tf:"token_secret_key,omitempty"`

	// Reference to a Secret in security to populate tokenSecretKey.
	// +kubebuilder:validation:Optional
	TokenSecretKeyRef *v1.NamespacedReference `json:"tokenSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate tokenSecretKey.
	// +kubebuilder:validation:Optional
	TokenSecretKeySelector *v1.NamespacedSelector `json:"tokenSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your auth type token is stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	TokenSecretScope *string `json:"tokenSecretScope,omitempty" tf:"token_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate tokenSecretScope.
	// +kubebuilder:validation:Optional
	TokenSecretScopeRef *v1.NamespacedReference `json:"tokenSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate tokenSecretScope.
	// +kubebuilder:validation:Optional
	TokenSecretScopeSelector *v1.NamespacedSelector `json:"tokenSecretScopeSelector,omitempty" tf:"-"`
}

type WasbObservation struct {

	// (String) This is the auth type for blob storage. This can either be SAS tokens (SAS) or account access keys (ACCESS_KEY).
	AuthType *string `json:"authType,omitempty" tf:"auth_type,omitempty"`

	// (String) The container in which the data is. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is the secret key in which your auth type token is stored.
	TokenSecretKey *string `json:"tokenSecretKey,omitempty" tf:"token_secret_key,omitempty"`

	// (String) This is the secret scope in which your auth type token is stored.
	TokenSecretScope *string `json:"tokenSecretScope,omitempty" tf:"token_secret_scope,omitempty"`
}

type WasbParameters struct {

	// (String) This is the auth type for blob storage. This can either be SAS tokens (SAS) or account access keys (ACCESS_KEY).
	// +kubebuilder:validation:Optional
	AuthType *string `json:"authType" tf:"auth_type,omitempty"`

	// (String) The container in which the data is. This is what you are trying to mount. (Could be omitted if resource_id is provided)
	// +kubebuilder:validation:Optional
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// (Computed) (String) This is optional if you don't want to add an additional directory that you wish to mount. This must start with a "/".
	// +kubebuilder:validation:Optional
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// (String) The name of the storage resource in which the data is. (Could be omitted if resource_id is provided)
	// +kubebuilder:validation:Optional
	StorageAccountName *string `json:"storageAccountName,omitempty" tf:"storage_account_name,omitempty"`

	// (String) This is the secret key in which your auth type token is stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.Secret
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("key",false)
	// +kubebuilder:validation:Optional
	TokenSecretKey *string `json:"tokenSecretKey,omitempty" tf:"token_secret_key,omitempty"`

	// Reference to a Secret in security to populate tokenSecretKey.
	// +kubebuilder:validation:Optional
	TokenSecretKeyRef *v1.NamespacedReference `json:"tokenSecretKeyRef,omitempty" tf:"-"`

	// Selector for a Secret in security to populate tokenSecretKey.
	// +kubebuilder:validation:Optional
	TokenSecretKeySelector *v1.NamespacedSelector `json:"tokenSecretKeySelector,omitempty" tf:"-"`

	// (String) This is the secret scope in which your auth type token is stored.
	// +crossplane:generate:reference:type=github.com/glalanne/provider-databricks/apis/namespaced/security/v1alpha1.SecretScope
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/v2/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	TokenSecretScope *string `json:"tokenSecretScope,omitempty" tf:"token_secret_scope,omitempty"`

	// Reference to a SecretScope in security to populate tokenSecretScope.
	// +kubebuilder:validation:Optional
	TokenSecretScopeRef *v1.NamespacedReference `json:"tokenSecretScopeRef,omitempty" tf:"-"`

	// Selector for a SecretScope in security to populate tokenSecretScope.
	// +kubebuilder:validation:Optional
	TokenSecretScopeSelector *v1.NamespacedSelector `json:"tokenSecretScopeSelector,omitempty" tf:"-"`
}

// MountSpec defines the desired state of Mount
type MountSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            MountParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MountInitParameters `json:"initProvider,omitempty"`
}

// MountStatus defines the observed state of Mount.
type MountStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MountObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Mount is the Schema for the Mounts API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,databricks}
type Mount struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MountSpec   `json:"spec"`
	Status            MountStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MountList contains a list of Mounts
type MountList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Mount `json:"items"`
}

// Repository type metadata.
var (
	Mount_Kind             = "Mount"
	Mount_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Mount_Kind}.String()
	Mount_KindAPIVersion   = Mount_Kind + "." + CRDGroupVersion.String()
	Mount_GroupVersionKind = CRDGroupVersion.WithKind(Mount_Kind)
)

func init() {
	SchemeBuilder.Register(&Mount{}, &MountList{})
}
