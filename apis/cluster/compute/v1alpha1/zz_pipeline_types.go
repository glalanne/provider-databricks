// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type ClusterAutoscaleInitParameters struct {
	MaxWorkers *float64 `json:"maxWorkers,omitempty" tf:"max_workers,omitempty"`

	MinWorkers *float64 `json:"minWorkers,omitempty" tf:"min_workers,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAutoscaleObservation struct {
	MaxWorkers *float64 `json:"maxWorkers,omitempty" tf:"max_workers,omitempty"`

	MinWorkers *float64 `json:"minWorkers,omitempty" tf:"min_workers,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAutoscaleParameters struct {

	// +kubebuilder:validation:Optional
	MaxWorkers *float64 `json:"maxWorkers" tf:"max_workers,omitempty"`

	// +kubebuilder:validation:Optional
	MinWorkers *float64 `json:"minWorkers" tf:"min_workers,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAwsAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAwsAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAwsAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	// +kubebuilder:validation:Optional
	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	// +kubebuilder:validation:Optional
	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAzureAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	LogAnalyticsInfo *ClusterAzureAttributesLogAnalyticsInfoInitParameters `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoInitParameters struct {
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoObservation struct {
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoParameters struct {

	// +kubebuilder:validation:Optional
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	LogAnalyticsInfo *ClusterAzureAttributesLogAnalyticsInfoObservation `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterAzureAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	LogAnalyticsInfo *ClusterAzureAttributesLogAnalyticsInfoParameters `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	// +kubebuilder:validation:Optional
	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterClusterLogConfDbfsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfDbfsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfDbfsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterClusterLogConfInitParameters struct {
	Dbfs *ClusterClusterLogConfDbfsInitParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	S3 *ClusterClusterLogConfS3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes *ClusterClusterLogConfVolumesInitParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type ClusterClusterLogConfObservation struct {
	Dbfs *ClusterClusterLogConfDbfsObservation `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	S3 *ClusterClusterLogConfS3Observation `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes *ClusterClusterLogConfVolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type ClusterClusterLogConfParameters struct {

	// +kubebuilder:validation:Optional
	Dbfs *ClusterClusterLogConfDbfsParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// +kubebuilder:validation:Optional
	S3 *ClusterClusterLogConfS3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`

	// +kubebuilder:validation:Optional
	Volumes *ClusterClusterLogConfVolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type ClusterClusterLogConfS3InitParameters struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterClusterLogConfS3Observation struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterClusterLogConfS3Parameters struct {

	// +kubebuilder:validation:Optional
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`

	// +kubebuilder:validation:Optional
	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterClusterLogConfVolumesInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfVolumesObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfVolumesParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterGCPAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterGCPAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterGCPAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterInitScriptsAbfssInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsAbfssObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsAbfssParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsInitParameters struct {
	Abfss *ClusterInitScriptsAbfssInitParameters `json:"abfss,omitempty" tf:"abfss,omitempty"`

	Dbfs *ClusterInitScriptsDbfsInitParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	File *ClusterInitScriptsFileInitParameters `json:"file,omitempty" tf:"file,omitempty"`

	Gcs *ClusterInitScriptsGcsInitParameters `json:"gcs,omitempty" tf:"gcs,omitempty"`

	S3 *ClusterInitScriptsS3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes *ClusterInitScriptsVolumesInitParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`

	Workspace *ClusterInitScriptsWorkspaceInitParameters `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsObservation struct {
	Abfss *ClusterInitScriptsAbfssObservation `json:"abfss,omitempty" tf:"abfss,omitempty"`

	Dbfs *ClusterInitScriptsDbfsObservation `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	File *ClusterInitScriptsFileObservation `json:"file,omitempty" tf:"file,omitempty"`

	Gcs *ClusterInitScriptsGcsObservation `json:"gcs,omitempty" tf:"gcs,omitempty"`

	S3 *ClusterInitScriptsS3Observation `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes *ClusterInitScriptsVolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`

	Workspace *ClusterInitScriptsWorkspaceObservation `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsParameters struct {

	// +kubebuilder:validation:Optional
	Abfss *ClusterInitScriptsAbfssParameters `json:"abfss,omitempty" tf:"abfss,omitempty"`

	// +kubebuilder:validation:Optional
	Dbfs *ClusterInitScriptsDbfsParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	// +kubebuilder:validation:Optional
	File *ClusterInitScriptsFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Gcs *ClusterInitScriptsGcsParameters `json:"gcs,omitempty" tf:"gcs,omitempty"`

	// +kubebuilder:validation:Optional
	S3 *ClusterInitScriptsS3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`

	// +kubebuilder:validation:Optional
	Volumes *ClusterInitScriptsVolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`

	// +kubebuilder:validation:Optional
	Workspace *ClusterInitScriptsWorkspaceParameters `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsS3InitParameters struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsS3Observation struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsS3Parameters struct {

	// +kubebuilder:validation:Optional
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`

	// +kubebuilder:validation:Optional
	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsVolumesInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsVolumesObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsVolumesParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type CronInitParameters struct {
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type CronObservation struct {
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type CronParameters struct {

	// +kubebuilder:validation:Optional
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type EventLogInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`
}

type EventLogObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`
}

type EventLogParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`
}

type FiltersInitParameters struct {

	// Paths to exclude.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type FiltersObservation struct {

	// Paths to exclude.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type FiltersParameters struct {

	// Paths to exclude.
	// +kubebuilder:validation:Optional
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type GatewayDefinitionInitParameters struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog,omitempty" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Lakeflow Declarative Pipelines system will automatically create the storage location under the catalog and schema.
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	GatewayStorageSchema *string `json:"gatewayStorageSchema,omitempty" tf:"gateway_storage_schema,omitempty"`
}

type GatewayDefinitionObservation struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog,omitempty" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Lakeflow Declarative Pipelines system will automatically create the storage location under the catalog and schema.
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	GatewayStorageSchema *string `json:"gatewayStorageSchema,omitempty" tf:"gateway_storage_schema,omitempty"`
}

type GatewayDefinitionParameters struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	// +kubebuilder:validation:Optional
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Lakeflow Declarative Pipelines system will automatically create the storage location under the catalog and schema.
	// +kubebuilder:validation:Optional
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	// +kubebuilder:validation:Optional
	GatewayStorageSchema *string `json:"gatewayStorageSchema" tf:"gateway_storage_schema,omitempty"`
}

type GlobInitParameters struct {

	// Paths to include.
	Include *string `json:"include,omitempty" tf:"include,omitempty"`
}

type GlobObservation struct {

	// Paths to include.
	Include *string `json:"include,omitempty" tf:"include,omitempty"`
}

type GlobParameters struct {

	// Paths to include.
	// +kubebuilder:validation:Optional
	Include *string `json:"include" tf:"include,omitempty"`
}

type IngestionDefinitionInitParameters struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	Objects []ObjectsInitParameters `json:"objects,omitempty" tf:"objects,omitempty"`

	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *IngestionDefinitionTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionObservation struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	Objects []ObjectsObservation `json:"objects,omitempty" tf:"objects,omitempty"`

	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *IngestionDefinitionTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionParameters struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	// +kubebuilder:validation:Optional
	Objects []ObjectsParameters `json:"objects,omitempty" tf:"objects,omitempty"`

	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration *IngestionDefinitionTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionTableConfigurationInitParameters struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *IngestionDefinitionTableConfigurationQueryBasedConnectorConfigInitParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type IngestionDefinitionTableConfigurationObservation struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *IngestionDefinitionTableConfigurationQueryBasedConnectorConfigObservation `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type IngestionDefinitionTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	QueryBasedConnectorConfig *IngestionDefinitionTableConfigurationQueryBasedConnectorConfigParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type IngestionDefinitionTableConfigurationQueryBasedConnectorConfigInitParameters struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type IngestionDefinitionTableConfigurationQueryBasedConnectorConfigObservation struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type IngestionDefinitionTableConfigurationQueryBasedConnectorConfigParameters struct {

	// +kubebuilder:validation:Optional
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	// +kubebuilder:validation:Optional
	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type LatestUpdatesInitParameters struct {
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LatestUpdatesObservation struct {
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LatestUpdatesParameters struct {

	// +kubebuilder:validation:Optional
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LibraryFileInitParameters struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type LibraryFileObservation struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type LibraryFileParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`
}

type ManualInitParameters struct {
}

type ManualObservation struct {
}

type ManualParameters struct {
}

type NotebookInitParameters struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type NotebookObservation struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type NotebookParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`
}

type NotificationInitParameters struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type NotificationObservation struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type NotificationParameters struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	// +kubebuilder:validation:Optional
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	// +kubebuilder:validation:Optional
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type ObjectsInitParameters struct {
	Report *ReportInitParameters `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *SchemaInitParameters `json:"schema,omitempty" tf:"schema,omitempty"`

	Table *ObjectsTableInitParameters `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsObservation struct {
	Report *ReportObservation `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *SchemaObservation `json:"schema,omitempty" tf:"schema,omitempty"`

	Table *ObjectsTableObservation `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsParameters struct {

	// +kubebuilder:validation:Optional
	Report *ReportParameters `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	Schema *SchemaParameters `json:"schema,omitempty" tf:"schema,omitempty"`

	// +kubebuilder:validation:Optional
	Table *ObjectsTableParameters `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsTableInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	SourceTable *string `json:"sourceTable,omitempty" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *TableTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ObjectsTableObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	SourceTable *string `json:"sourceTable,omitempty" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *TableTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ObjectsTableParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// +kubebuilder:validation:Optional
	SourceTable *string `json:"sourceTable" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration *TableTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type PipelineClusterInitParameters struct {
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	Autoscale *ClusterAutoscaleInitParameters `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	AwsAttributes *ClusterAwsAttributesInitParameters `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	AzureAttributes *ClusterAzureAttributesInitParameters `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	ClusterLogConf *ClusterClusterLogConfInitParameters `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	GCPAttributes *ClusterGCPAttributesInitParameters `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	InitScripts []ClusterInitScriptsInitParameters `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineClusterObservation struct {
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	Autoscale *ClusterAutoscaleObservation `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	AwsAttributes *ClusterAwsAttributesObservation `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	AzureAttributes *ClusterAzureAttributesObservation `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	ClusterLogConf *ClusterClusterLogConfObservation `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	GCPAttributes *ClusterGCPAttributesObservation `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	InitScripts []ClusterInitScriptsObservation `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineClusterParameters struct {

	// +kubebuilder:validation:Optional
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	// +kubebuilder:validation:Optional
	Autoscale *ClusterAutoscaleParameters `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	// +kubebuilder:validation:Optional
	AwsAttributes *ClusterAwsAttributesParameters `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	AzureAttributes *ClusterAzureAttributesParameters `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterLogConf *ClusterClusterLogConfParameters `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	GCPAttributes *ClusterGCPAttributesParameters `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	InitScripts []ClusterInitScriptsParameters `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	// +kubebuilder:validation:Optional
	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineDeploymentInitParameters struct {

	// The deployment method that manages the pipeline.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineDeploymentObservation struct {

	// The deployment method that manages the pipeline.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineDeploymentParameters struct {

	// The deployment method that manages the pipeline.
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	// +kubebuilder:validation:Optional
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineEnvironmentInitParameters struct {

	// a list of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See API docs for more information.
	Dependencies []*string `json:"dependencies,omitempty" tf:"dependencies,omitempty"`
}

type PipelineEnvironmentObservation struct {

	// a list of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See API docs for more information.
	Dependencies []*string `json:"dependencies,omitempty" tf:"dependencies,omitempty"`
}

type PipelineEnvironmentParameters struct {

	// a list of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See API docs for more information.
	// +kubebuilder:validation:Optional
	Dependencies []*string `json:"dependencies,omitempty" tf:"dependencies,omitempty"`
}

type PipelineInitParameters struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this Lakeflow Declarative Pipeline.
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by Lakeflow Declarative Pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that Lakeflow Declarative Pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	Cluster []PipelineClusterInitParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	Deployment *PipelineDeploymentInitParameters `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	Environment *PipelineEnvironmentInitParameters `json:"environment,omitempty" tf:"environment,omitempty"`

	// an optional block specifying a table where LDP Event Log will be stored.  Consists of the following fields:
	EventLog *EventLogInitParameters `json:"eventLog,omitempty" tf:"event_log,omitempty"`

	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	Filters *FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	GatewayDefinition *GatewayDefinitionInitParameters `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	IngestionDefinition *IngestionDefinitionInitParameters `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	LatestUpdates []LatestUpdatesInitParameters `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code.
	Library []PipelineLibraryInitParameters `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Notification []NotificationInitParameters `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	RestartWindow *RestartWindowInitParameters `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// An optional string specifying the root path for this pipeline. This is used as the root directory when editing the pipeline in the Databricks user interface and it is added to sys.path when executing Python sources during pipeline execution.
	RootPath *string `json:"rootPath,omitempty" tf:"root_path,omitempty"`

	RunAs *PipelineRunAsInitParameters `json:"runAs,omitempty" tf:"run_as,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this Lakeflow Declarative Pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	Trigger *PipelineTriggerInitParameters `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineLibraryInitParameters struct {

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	File *LibraryFileInitParameters `json:"file,omitempty" tf:"file,omitempty"`

	// The unified field to include source code. Each entry should have the include attribute that can specify a notebook path, a file path, or a folder path that ends /** (to include everything from that folder). This field cannot be used together with notebook or file.
	Glob *GlobInitParameters `json:"glob,omitempty" tf:"glob,omitempty"`

	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	Maven *PipelineLibraryMavenInitParameters `json:"maven,omitempty" tf:"maven,omitempty"`

	// specifies path to a Databricks Notebook to include as source. Actual path is specified as path attribute inside the block.
	Notebook *NotebookInitParameters `json:"notebook,omitempty" tf:"notebook,omitempty"`

	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineLibraryMavenInitParameters struct {
	Coordinates *string `json:"coordinates,omitempty" tf:"coordinates,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryMavenObservation struct {
	Coordinates *string `json:"coordinates,omitempty" tf:"coordinates,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryMavenParameters struct {

	// +kubebuilder:validation:Optional
	Coordinates *string `json:"coordinates" tf:"coordinates,omitempty"`

	// +kubebuilder:validation:Optional
	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	// +kubebuilder:validation:Optional
	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryObservation struct {

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	File *LibraryFileObservation `json:"file,omitempty" tf:"file,omitempty"`

	// The unified field to include source code. Each entry should have the include attribute that can specify a notebook path, a file path, or a folder path that ends /** (to include everything from that folder). This field cannot be used together with notebook or file.
	Glob *GlobObservation `json:"glob,omitempty" tf:"glob,omitempty"`

	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	Maven *PipelineLibraryMavenObservation `json:"maven,omitempty" tf:"maven,omitempty"`

	// specifies path to a Databricks Notebook to include as source. Actual path is specified as path attribute inside the block.
	Notebook *NotebookObservation `json:"notebook,omitempty" tf:"notebook,omitempty"`

	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineLibraryParameters struct {

	// specifies path to a file in Databricks Workspace to include as source. Actual path is specified as path attribute inside the block.
	// +kubebuilder:validation:Optional
	File *LibraryFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// The unified field to include source code. Each entry should have the include attribute that can specify a notebook path, a file path, or a folder path that ends /** (to include everything from that folder). This field cannot be used together with notebook or file.
	// +kubebuilder:validation:Optional
	Glob *GlobParameters `json:"glob,omitempty" tf:"glob,omitempty"`

	// +kubebuilder:validation:Optional
	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	// +kubebuilder:validation:Optional
	Maven *PipelineLibraryMavenParameters `json:"maven,omitempty" tf:"maven,omitempty"`

	// specifies path to a Databricks Notebook to include as source. Actual path is specified as path attribute inside the block.
	// +kubebuilder:validation:Optional
	Notebook *NotebookParameters `json:"notebook,omitempty" tf:"notebook,omitempty"`

	// +kubebuilder:validation:Optional
	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineObservation struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this Lakeflow Declarative Pipeline.
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by Lakeflow Declarative Pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that Lakeflow Declarative Pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	Cluster []PipelineClusterObservation `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	Deployment *PipelineDeploymentObservation `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	Environment *PipelineEnvironmentObservation `json:"environment,omitempty" tf:"environment,omitempty"`

	// an optional block specifying a table where LDP Event Log will be stored.  Consists of the following fields:
	EventLog *EventLogObservation `json:"eventLog,omitempty" tf:"event_log,omitempty"`

	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	Filters *FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	GatewayDefinition *GatewayDefinitionObservation `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IngestionDefinition *IngestionDefinitionObservation `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	LatestUpdates []LatestUpdatesObservation `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code.
	Library []PipelineLibraryObservation `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Notification []NotificationObservation `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	RestartWindow *RestartWindowObservation `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// An optional string specifying the root path for this pipeline. This is used as the root directory when editing the pipeline in the Databricks user interface and it is added to sys.path when executing Python sources during pipeline execution.
	RootPath *string `json:"rootPath,omitempty" tf:"root_path,omitempty"`

	RunAs *PipelineRunAsObservation `json:"runAs,omitempty" tf:"run_as,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this Lakeflow Declarative Pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	Trigger *PipelineTriggerObservation `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineParameters struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	// +kubebuilder:validation:Optional
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	// +kubebuilder:validation:Optional
	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by Lakeflow Declarative Pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	// +kubebuilder:validation:Optional
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that Lakeflow Declarative Pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	// +kubebuilder:validation:Optional
	Cluster []PipelineClusterParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	// +kubebuilder:validation:Optional
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	// +kubebuilder:validation:Optional
	Deployment *PipelineDeploymentParameters `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	// +kubebuilder:validation:Optional
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	// +kubebuilder:validation:Optional
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	// +kubebuilder:validation:Optional
	Environment *PipelineEnvironmentParameters `json:"environment,omitempty" tf:"environment,omitempty"`

	// an optional block specifying a table where LDP Event Log will be stored.  Consists of the following fields:
	// +kubebuilder:validation:Optional
	EventLog *EventLogParameters `json:"eventLog,omitempty" tf:"event_log,omitempty"`

	// +kubebuilder:validation:Optional
	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	// +kubebuilder:validation:Optional
	Filters *FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	// +kubebuilder:validation:Optional
	GatewayDefinition *GatewayDefinitionParameters `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	// +kubebuilder:validation:Optional
	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	// +kubebuilder:validation:Optional
	IngestionDefinition *IngestionDefinitionParameters `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	// +kubebuilder:validation:Optional
	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	// +kubebuilder:validation:Optional
	LatestUpdates []LatestUpdatesParameters `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code.
	// +kubebuilder:validation:Optional
	Library []PipelineLibraryParameters `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Notification []NotificationParameters `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	// +kubebuilder:validation:Optional
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	// +kubebuilder:validation:Optional
	RestartWindow *RestartWindowParameters `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// An optional string specifying the root path for this pipeline. This is used as the root directory when editing the pipeline in the Databricks user interface and it is added to sys.path when executing Python sources during pipeline execution.
	// +kubebuilder:validation:Optional
	RootPath *string `json:"rootPath,omitempty" tf:"root_path,omitempty"`

	// +kubebuilder:validation:Optional
	RunAs *PipelineRunAsParameters `json:"runAs,omitempty" tf:"run_as,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this Lakeflow Declarative Pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	// +kubebuilder:validation:Optional
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	// +kubebuilder:validation:Optional
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// A map of tags associated with the pipeline. These are forwarded to the cluster as cluster tags, and are therefore subject to the same limitations. A maximum of 25 tags can be added to the pipeline.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Trigger *PipelineTriggerParameters `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineRunAsInitParameters struct {

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	ServicePrincipalName *string `json:"servicePrincipalName,omitempty" tf:"service_principal_name,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

type PipelineRunAsObservation struct {

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	ServicePrincipalName *string `json:"servicePrincipalName,omitempty" tf:"service_principal_name,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

type PipelineRunAsParameters struct {

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	ServicePrincipalName *string `json:"servicePrincipalName,omitempty" tf:"service_principal_name,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

type PipelineTriggerInitParameters struct {
	Cron *CronInitParameters `json:"cron,omitempty" tf:"cron,omitempty"`

	Manual *ManualInitParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type PipelineTriggerObservation struct {
	Cron *CronObservation `json:"cron,omitempty" tf:"cron,omitempty"`

	Manual *ManualParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type PipelineTriggerParameters struct {

	// +kubebuilder:validation:Optional
	Cron *CronParameters `json:"cron,omitempty" tf:"cron,omitempty"`

	// +kubebuilder:validation:Optional
	Manual *ManualParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type QueryBasedConnectorConfigInitParameters struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type QueryBasedConnectorConfigObservation struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type QueryBasedConnectorConfigParameters struct {

	// +kubebuilder:validation:Optional
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	// +kubebuilder:validation:Optional
	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type ReportInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	SourceURL *string `json:"sourceUrl,omitempty" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *TableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ReportObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	SourceURL *string `json:"sourceUrl,omitempty" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *TableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ReportParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the Lakeflow Declarative Pipeline on the given workspace.
	// +kubebuilder:validation:Optional
	SourceURL *string `json:"sourceUrl" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration *TableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type RestartWindowInitParameters struct {
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	StartHour *float64 `json:"startHour,omitempty" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type RestartWindowObservation struct {
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	StartHour *float64 `json:"startHour,omitempty" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type RestartWindowParameters struct {

	// +kubebuilder:validation:Optional
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// +kubebuilder:validation:Optional
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the Lakeflow Declarative Pipeline.
	// +kubebuilder:validation:Optional
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type SchemaInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *SchemaTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration *SchemaTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	SourceSchema *string `json:"sourceSchema" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration *SchemaTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaTableConfigurationInitParameters struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *TableConfigurationQueryBasedConnectorConfigInitParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type SchemaTableConfigurationObservation struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *TableConfigurationQueryBasedConnectorConfigObservation `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type SchemaTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	QueryBasedConnectorConfig *TableConfigurationQueryBasedConnectorConfigParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationInitParameters struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *QueryBasedConnectorConfigInitParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationObservation struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *QueryBasedConnectorConfigObservation `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	QueryBasedConnectorConfig *QueryBasedConnectorConfigParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationQueryBasedConnectorConfigInitParameters struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type TableConfigurationQueryBasedConnectorConfigObservation struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type TableConfigurationQueryBasedConnectorConfigParameters struct {

	// +kubebuilder:validation:Optional
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	// +kubebuilder:validation:Optional
	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type TableTableConfigurationInitParameters struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *TableTableConfigurationQueryBasedConnectorConfigInitParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationObservation struct {
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	QueryBasedConnectorConfig *TableTableConfigurationQueryBasedConnectorConfigObservation `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ExcludeColumns []*string `json:"excludeColumns,omitempty" tf:"exclude_columns,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeColumns []*string `json:"includeColumns,omitempty" tf:"include_columns,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	QueryBasedConnectorConfig *TableTableConfigurationQueryBasedConnectorConfigParameters `json:"queryBasedConnectorConfig,omitempty" tf:"query_based_connector_config,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationQueryBasedConnectorConfigInitParameters struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type TableTableConfigurationQueryBasedConnectorConfigObservation struct {
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

type TableTableConfigurationQueryBasedConnectorConfigParameters struct {

	// +kubebuilder:validation:Optional
	CursorColumns []*string `json:"cursorColumns,omitempty" tf:"cursor_columns,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionCondition *string `json:"deletionCondition,omitempty" tf:"deletion_condition,omitempty"`

	// +kubebuilder:validation:Optional
	HardDeletionSyncMinIntervalInSeconds *float64 `json:"hardDeletionSyncMinIntervalInSeconds,omitempty" tf:"hard_deletion_sync_min_interval_in_seconds,omitempty"`
}

// PipelineSpec defines the desired state of Pipeline
type PipelineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PipelineParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider PipelineInitParameters `json:"initProvider,omitempty"`
}

// PipelineStatus defines the observed state of Pipeline.
type PipelineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PipelineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Pipeline is the Schema for the Pipelines API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,databricks}
type Pipeline struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PipelineSpec   `json:"spec"`
	Status            PipelineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PipelineList contains a list of Pipelines
type PipelineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Pipeline `json:"items"`
}

// Repository type metadata.
var (
	Pipeline_Kind             = "Pipeline"
	Pipeline_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Pipeline_Kind}.String()
	Pipeline_KindAPIVersion   = Pipeline_Kind + "." + CRDGroupVersion.String()
	Pipeline_GroupVersionKind = CRDGroupVersion.WithKind(Pipeline_Kind)
)

func init() {
	SchemeBuilder.Register(&Pipeline{}, &PipelineList{})
}
